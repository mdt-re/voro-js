<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voro-js Shaded Faces Visualization</title>
    <style>
        body { margin: 0; font-family: sans-serif; background-color: #111; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #fff;
            z-index: 100;
            display:block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div id="info">Voro-js: Shaded Voronoi Cell Faces with Three.js</div>
    <div id="loading">Loading Voro++ Module...</div>

    <!-- Three.js library from a CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Dynamically import the voro.js module.
        import('/dist/voro_browser.js').then(voroModule => {
            return voroModule.default(); // This calls initializeVoro()
        }).then(Voro => {
            document.getElementById('loading').style.display = 'none';
            main(Voro);
        }).catch(err => {
            console.error("Failed to initialize Voro++ module:", err);
            document.getElementById('loading').innerText = 'Error loading Voro++ module. See console for details.';
        });

        function main(Voro) {
            // --- 1. Three.js Scene Setup ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 15, 15);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);

            // Add lighting for the shaded materials
            const ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 20, 5);
            scene.add(directionalLight);

            // --- 2. Voro++ Computation ---
            const bounds = {
                minX: 0, maxX: 10,
                minY: 0, maxY: 10,
                minZ: 0, maxZ: 10
            };

            // Create a bounding box visualizer
            const boxGeometry = new THREE.BoxGeometry(bounds.maxX - bounds.minX, bounds.maxY - bounds.minY, bounds.maxZ - bounds.minZ);
            const boxEdges = new THREE.EdgesGeometry(boxGeometry);
            const boxLines = new THREE.LineSegments(boxEdges, new THREE.LineBasicMaterial({ color: 0xaaaaaa }));
            boxLines.position.set(
                (bounds.minX + bounds.maxX) / 2,
                (bounds.minY + bounds.maxY) / 2,
                (bounds.minZ + bounds.maxZ) / 2
            );
            scene.add(boxLines);

            // Create a Voronoi context
            const context = new Voro.VoronoiContext3D(
                bounds.minX, bounds.maxX,
                bounds.minY, bounds.maxY,
                bounds.minZ, bounds.maxZ,
                8, 8, 8
            );

            // Generate some random points
            const numPoints = 50;
            const points = [];
            for (let i = 0; i < numPoints; i++) {
                const p = {
                    id: i,
                    x: bounds.minX + Math.random() * (bounds.maxX - bounds.minX),
                    y: bounds.minY + Math.random() * (bounds.maxY - bounds.minY),
                    z: bounds.minZ + Math.random() * (bounds.maxZ - bounds.minZ),
                };
                points.push(p);
                context.addPoint(p.id, p.x, p.y, p.z);
            }

            // Compute all Voronoi cells
            const emscriptenCells = context.getAllCells();
            
            // --- 3. Convert Emscripten objects to JS and clean up memory ---
            // These helpers are crucial for converting the data returned
            // from WebAssembly into standard JavaScript arrays and for correctly
            // freeing the C++ memory allocated by Emscripten.

            function convertPointsToJsArray(emscriptenPoints) {
                const jsPoints = [];
                if (!emscriptenPoints) return jsPoints;
                for (let i = 0; i < emscriptenPoints.size(); i++) {
                    jsPoints.push(emscriptenPoints.get(i));
                }
                emscriptenPoints.delete();
                return jsPoints;
            }

            function convertIntVectorToJsArray(emscriptenIntVector) {
                const jsArray = [];
                if (!emscriptenIntVector) return jsArray;
                for (let i = 0; i < emscriptenIntVector.size(); i++) {
                    jsArray.push(emscriptenIntVector.get(i));
                }
                emscriptenIntVector.delete();
                return jsArray;
            }

            function convertVectorVectorIntToJsArray(emscriptenVectorVectorInt) {
                const jsArray = [];
                if (!emscriptenVectorVectorInt) return jsArray;
                for (let i = 0; i < emscriptenVectorVectorInt.size(); i++) {
                    const nestedEmscriptenIntVector = emscriptenVectorVectorInt.get(i);
                    jsArray.push(convertIntVectorToJsArray(nestedEmscriptenIntVector));
                }
                emscriptenVectorVectorInt.delete();
                return jsArray;
            }

            function convertCellsToJsArray(emscriptenCells) {
                const jsCells = [];
                if (!emscriptenCells) return jsCells;
                for (let i = 0; i < emscriptenCells.size(); i++) {
                    const cell = emscriptenCells.get(i);
                    // Create a new JS object and copy the data.
                    // This is safer than passing the emscripten object directly.
                    const jsCell = {
                        id: cell.id,
                        x: cell.x, y: cell.y, z: cell.z,
                        vertices: convertPointsToJsArray(cell.vertices),
                        edges: convertVectorVectorIntToJsArray(cell.edges),
                        faces: convertVectorVectorIntToJsArray(cell.faces),
                        neighbors: convertIntVectorToJsArray(cell.neighbors)
                    };
                    jsCells.push(jsCell);
                    //cell.delete(); // Free the C++ cell object
                }
                emscriptenCells.delete(); // Free the top-level C++ vector
                return jsCells;
            }

            const cells = convertCellsToJsArray(emscriptenCells);

            // Clean up the context now that we have the data
            context.clear();
            context.delete();

            // --- 4. Visualize the Cells with Three.js ---

            // Add points to the scene as small spheres
            const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 8); // radius, widthSegments, heightSegments
            const sphereMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc, // Light gray
                roughness: 0.8   // Make it non-reflective
            });

            points.forEach(p => {
                const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphereMesh.position.set(p.x, p.y, p.z);
                scene.add(sphereMesh);
            });

            // Add cell meshes to the scene
            cells.forEach(cell => {
                if (cell.vertices.length === 0 || cell.faces.length === 0) return;

                const vertices = cell.vertices.map(v => new THREE.Vector3(v.x, v.y, v.z));
                
                // Triangulate the polygonal faces
                // Since Voronoi faces are convex, we can use a simple fan triangulation.
                const indices = [];
                cell.faces.forEach(face => {
                    const v0 = face[0];
                    for (let i = 1; i < face.length - 1; i++) {
                        const v1 = face[i];
                        const v2 = face[i + 1];
                        indices.push(v0, v1, v2);
                    }
                });

                const cellGeometry = new THREE.BufferGeometry().setFromPoints(vertices);
                cellGeometry.setIndex(indices);
                cellGeometry.computeVertexNormals(); // For correct lighting

                // Create a mesh for the cell with a random color
                const cellMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                    roughness: 0.5,
                    metalness: 0.1,
                    transparent: true,
                    opacity: 0.8
                });

                const cellMesh = new THREE.Mesh(cellGeometry, cellMaterial);
                scene.add(cellMesh);

                // Optional: Add a wireframe overlay
                const wireframeGeometry = new THREE.EdgesGeometry(cellGeometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
                const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                scene.add(wireframe);
            });

            // --- 5. Animation Loop ---
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }

            animate();

            // Handle window resizing
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    </script>
</body>
</html>