<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voro-js 3D Visualization Example</title>
    <style>
        body { margin: 0; font-family: sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #fff;
            z-index: 100;
            display:block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div id="info">Voro-js 3D Voronoi Diagram Visualization with Three.js</div>
    <div id="loading">Loading Voro++ Module...</div>

    <!-- Three.js library from a CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- 
      voro-js library. 
      This path assumes the example is in an `examples/` directory and the built
      browser-compatible library is in the `dist/` directory.
      Adjust the path if your project structure is different.
    -->
    <!-- We will now import voro.js dynamically from within our module script -->
    <!-- <script src="../dist/voro.js" defer></script> -->

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Dynamically import the voro.js module. This returns a module object.
        // The default export is the initializeVoro function.
        import('../dist/voro_browser.js').then(voroModule => {
            return voroModule.default(); // This calls initializeVoro()
        }).then(Voro => {
            document.getElementById('loading').style.display = 'none';
            main(Voro);
        }).catch(err => {
            console.error("Failed to initialize Voro++ module:", err);
            document.getElementById('loading').innerText = 'Error loading Voro++ module. See console for details.';
        });

        function main(Voro) {
            // --- 1. Three.js Scene Setup ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 15, 15);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);

            // Add some lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(10, 20, 5);
            scene.add(directionalLight);

            // --- 2. Voro++ Computation ---
            const bounds = {
                minX: 0, maxX: 10,
                minY: 0, maxY: 10,
                minZ: 0, maxZ: 10
            };

            // Create a bounding box visualizer
            const boxGeometry = new THREE.BoxGeometry(bounds.maxX - bounds.minX, bounds.maxY - bounds.minY, bounds.maxZ - bounds.minZ);
            const boxEdges = new THREE.EdgesGeometry(boxGeometry);
            const boxLines = new THREE.LineSegments(boxEdges, new THREE.LineBasicMaterial({ color: 0xffffff }));
            boxLines.position.set(
                (bounds.minX + bounds.maxX) / 2,
                (bounds.minY + bounds.maxY) / 2,
                (bounds.minZ + bounds.maxZ) / 2
            );
            scene.add(boxLines);

            // Create a Voronoi context
            const context = new Voro.VoronoiContext3D(
                bounds.minX, bounds.maxX,
                bounds.minY, bounds.maxY,
                bounds.minZ, bounds.maxZ,
                8, 8, 8
            );

            // Generate some random points
            const numPoints = 50;
            const points = [];
            for (let i = 0; i < numPoints; i++) {
                const p = {
                    id: i,
                    x: bounds.minX + Math.random() * (bounds.maxX - bounds.minX),
                    y: bounds.minY + Math.random() * (bounds.maxY - bounds.minY),
                    z: bounds.minZ + Math.random() * (bounds.maxZ - bounds.minZ),
                };
                points.push(p);
                context.addPoint(p.id, p.x, p.y, p.z);
            }

            // Compute all Voronoi cells
            const emscriptenCells = context.getAllCells();
            
            // --- 3. Convert Emscripten objects to JS and clean up memory ---
            // These helper functions are crucial for converting the data returned
            // from WebAssembly into standard JavaScript arrays and for correctly
            // freeing the C++ memory allocated by Emscripten.

            function convertPointsToJsArray(emscriptenPoints) {
                const jsPoints = [];
                if (!emscriptenPoints) return jsPoints;
                for (let i = 0; i < emscriptenPoints.size(); i++) {
                    jsPoints.push(emscriptenPoints.get(i));
                }
                emscriptenPoints.delete();
                return jsPoints;
            }

            function convertIntVectorToJsArray(emscriptenIntVector) {
                const jsArray = [];
                if (!emscriptenIntVector) return jsArray;
                for (let i = 0; i < emscriptenIntVector.size(); i++) {
                    jsArray.push(emscriptenIntVector.get(i));
                }
                emscriptenIntVector.delete();
                return jsArray;
            }

            function convertVectorVectorIntToJsArray(emscriptenVectorVectorInt) {
                const jsArray = [];
                if (!emscriptenVectorVectorInt) return jsArray;
                for (let i = 0; i < emscriptenVectorVectorInt.size(); i++) {
                    const nestedEmscriptenIntVector = emscriptenVectorVectorInt.get(i);
                    jsArray.push(convertIntVectorToJsArray(nestedEmscriptenIntVector));
                }
                emscriptenVectorVectorInt.delete();
                return jsArray;
            }

            function convertCellsToJsArray(emscriptenCells) {
                const jsCells = [];
                if (!emscriptenCells) return jsCells;
                for (let i = 0; i < emscriptenCells.size(); i++) {
                    const cell = emscriptenCells.get(i);
                    cell.vertices = convertPointsToJsArray(cell.vertices);
                    cell.edges = convertVectorVectorIntToJsArray(cell.edges);
                    cell.faces = convertVectorVectorIntToJsArray(cell.faces);
                    cell.neighbors = convertIntVectorToJsArray(cell.neighbors);
                    jsCells.push(cell);
                    //cell.delete();
                }
                emscriptenCells.delete();
                return jsCells;
            }

            const cells = convertCellsToJsArray(emscriptenCells);

            // Clean up the context now that we have the data
            context.clear();
            context.delete();

            // --- 4. Visualize the Cells with Three.js ---

            // Add points to the scene
            const pointGeometry = new THREE.BufferGeometry();
            const pointPositions = new Float32Array(points.length * 3);
            points.forEach((p, i) => {
                pointPositions[i * 3] = p.x;
                pointPositions[i * 3 + 1] = p.y;
                pointPositions[i * 3 + 2] = p.z;
            });
            pointGeometry.setAttribute('position', new THREE.BufferAttribute(pointPositions, 3));
            const pointMaterial = new THREE.PointsMaterial({ color: 0xff0000, size: 0.2 });
            const pointCloud = new THREE.Points(pointGeometry, pointMaterial);
            scene.add(pointCloud);

            // Add cell wireframes to the scene
            const cellMaterial = new THREE.LineBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.5
            });

            cells.forEach(cell => {
                if (cell.vertices.length === 0) return;

                const vertices = cell.vertices.map(v => new THREE.Vector3(v.x, v.y, v.z));
                
                // Create wireframe from edges
                const edgeIndices = [];
                cell.edges.forEach(edge => {
                    // Voro++ edges are pairs of vertex indices
                    if (edge.length === 2) {
                        edgeIndices.push(edge[0], edge[1]);
                    }
                });

                const cellGeometry = new THREE.BufferGeometry().setFromPoints(vertices);
                cellGeometry.setIndex(edgeIndices);

                const cellWireframe = new THREE.LineSegments(cellGeometry, cellMaterial);
                scene.add(cellWireframe);
            });

            // --- 5. Animation Loop ---
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }

            animate();

            // Handle window resizing
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    </script>
</body>
</html>