<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>voro-js Example: Performance Demo</title>
    <style>
        body { margin: 0; font-family: sans-serif; overflow: hidden; background-color: #111; color: #fff; }
        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            max-width: 300px;
            text-align: left;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #results {
            position: absolute;
            top: 120px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            font-family: monospace;
            white-space: pre;
            z-index: 10;
            display: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2em;
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 10px;
        }
        h2 { margin: 0 0 5px 0; font-size: 1.2em; }
        p { margin: 0; font-size: 0.9em; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>
</head>
<body>
    <div id="info">
        <h2>Performance Demo</h2>
        <p>Benchmark Voronoi generation speed.</p>
    </div>
    <div id="results"></div>
    <div id="loading">Loading Voro++ Module...</div>
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';
        import Stats from 'three/addons/libs/stats.module.js';

        import('../dist/voro_browser.js').then(voroModule => {
            return voroModule.default();
        }).then(Voro => {
            document.getElementById('loading').style.display = 'none';
            initApp(Voro);
        }).catch(err => {
            console.error("Failed to initialize Voro++ module:", err);
            document.getElementById('loading').innerText = 'Error loading Voro++ module.';
        });

        function initApp(Voro) {
            // --- Three.js Setup ---
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(40, 30, 40);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // Visualization Group
            const visGroup = new THREE.Group();
            scene.add(visGroup);

            // --- Benchmark Logic ---
            const params = {
                count: 1000,
                boxSize: 20,
                render: true,
                run: () => runBenchmark()
            };

            const gui = new GUI();
            gui.add(params, 'count', 100, 50000, 100).name('Particle Count');
            gui.add(params, 'boxSize', 10, 100).name('Box Size');
            gui.add(params, 'render').name('Render Result');
            gui.add(params, 'run').name('Run Benchmark');

            // Stats
            const stats = new Stats();
            stats.dom.style.cssText = 'position:relative;top:auto;left:auto;display:block;margin:10px auto;';
            const statsFolder = gui.addFolder('Stats');
            statsFolder.domElement.querySelector('.children').appendChild(stats.dom);

            function runBenchmark() {
                const resultsDiv = document.getElementById('results');
                resultsDiv.style.display = 'block';
                resultsDiv.innerText = 'Running...';

                // Use setTimeout to allow UI to update before heavy processing
                setTimeout(() => {
                    try {
                        // 1. Data Generation (JS Side)
                        const t0 = performance.now();
                        const ids = new Int32Array(params.count);
                        const x = new Float64Array(params.count);
                        const y = new Float64Array(params.count);
                        const z = new Float64Array(params.count);

                        for(let i=0; i<params.count; i++) {
                            ids[i] = i;
                            x[i] = (Math.random() - 0.5) * params.boxSize;
                            y[i] = (Math.random() - 0.5) * params.boxSize;
                            z[i] = (Math.random() - 0.5) * params.boxSize;
                        }
                        const tGen = performance.now() - t0;

                        // 2. Data Marshalling (JS -> C++)
                        const t1 = performance.now();
                        const emIds = new Voro.VectorInt();
                        const emX = new Voro.VectorDouble();
                        const emY = new Voro.VectorDouble();
                        const emZ = new Voro.VectorDouble();

                        // Resize vectors first to avoid reallocations (if resize is exposed, otherwise push_back)
                        // The bindings use push_back in the test, let's stick to that or resize if available.
                        // Standard vector bindings usually expose push_back.
                        for(let i=0; i<params.count; i++) {
                            emIds.push_back(ids[i]);
                            emX.push_back(x[i]);
                            emY.push_back(y[i]);
                            emZ.push_back(z[i]);
                        }
                        const tMarshal = performance.now() - t1;

                        // 3. Context Initialization & Insertion
                        const t2 = performance.now();
                        const half = params.boxSize / 2;
                        // Heuristic for blocks: ~ cube root of N
                        const n = Math.max(1, Math.floor(Math.pow(params.count, 1/3)));
                        
                        const context = new Voro.VoronoiContext3D(
                            -half, half, -half, half, -half, half,
                            n, n, n
                        );
                        context.addPoints(emIds, emX, emY, emZ);
                        const tInsert = performance.now() - t2;

                        // 4. Computation & Extraction
                        const t3 = performance.now();
                        const cells = context.getCells(); // This returns JS array of objects
                        const tCompute = performance.now() - t3;

                        // Cleanup C++ objects
                        context.delete();
                        emIds.delete();
                        emX.delete();
                        emY.delete();
                        emZ.delete();

                        // 5. Visualization (Optional)
                        visGroup.clear();
                        if (params.render) {
                            if (params.count > 50000) {
                                // Render points only for performance
                                const geo = new THREE.BufferGeometry();
                                geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(params.count * 3), 3));
                                const pos = geo.attributes.position.array;
                                for(let i=0; i<params.count; i++) {
                                    pos[i*3] = x[i];
                                    pos[i*3+1] = y[i];
                                    pos[i*3+2] = z[i];
                                }
                                const mat = new THREE.PointsMaterial({ color: 0x00ff88, size: 0.2 });
                                visGroup.add(new THREE.Points(geo, mat));
                            } else {
                                // Render wireframe cells
                                const vertices = [];
                                cells.forEach(cell => {
                                    if(cell.vertices && cell.faces) {
                                        cell.faces.forEach(face => {
                                            for(let j=0; j<face.length; j++) {
                                                const v1 = cell.vertices[face[j]];
                                                const v2 = cell.vertices[face[(j+1)%face.length]];
                                                vertices.push(v1.x, v1.y, v1.z);
                                                vertices.push(v2.x, v2.y, v2.z);
                                            }
                                        });
                                    }
                                });
                                const geo = new THREE.BufferGeometry();
                                geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                                const mat = new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.3 });
                                visGroup.add(new THREE.LineSegments(geo, mat));
                            }
                        }

                        // Report
                        const total = tGen + tMarshal + tInsert + tCompute;
                        resultsDiv.innerText = 
                            `Particles:    ${params.count}\n` +
                            `------------------------\n` +
                            `JS Gen:       ${tGen.toFixed(2)} ms\n` +
                            `Marshalling:  ${tMarshal.toFixed(2)} ms\n` +
                            `Insertion:    ${tInsert.toFixed(2)} ms\n` +
                            `Compute+Extr: ${tCompute.toFixed(2)} ms\n` +
                            `------------------------\n` +
                            `Total:        ${total.toFixed(2)} ms\n` +
                            `FPS (equiv):  ${(1000/total).toFixed(1)}`;

                    } catch (e) {
                        console.error(e);
                        resultsDiv.innerText = "Error: " + e.message;
                    }
                }, 10);
            }

            // Animation Loop
            function animate() {
                requestAnimationFrame(animate);
                stats.update();
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            // Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Handle screenshot
            window.addEventListener('keydown', (event) => {
                if (event.key === 'p') {
                    renderer.render(scene, camera);
                    const link = document.createElement('a');
                    link.download = 'voro_performance.png';
                    link.href = renderer.domElement.toDataURL('image/png');
                    link.click();
                }
            });

            // Auto-run once
            runBenchmark();
        }
    </script>
</body>
</html>